# Sticky Scrollbar 技术设计文档

## 1. 架构设计

### 1.1 整体架构

采用模块化设计，核心分为三层：

- **核心层**：滚动同步引擎、DOM 计算引擎
- **交互层**：事件处理系统、用户交互管理
- **展示层**：滚动条渲染、样式管理

### 1.2 技术栈

- **语言**：TypeScript 5.0+
- **构建**：Rollup + Babel
- **样式**：CSS-in-JS + CSS Variables
- **测试**：Jest + Playwright
- **打包**：支持 UMD、ESM、CJS 格式

## 2. 核心模块设计

### 2.1 类结构设计

```typescript
// 主类结构
class StickyScrollbar {
  private container: HTMLElement;
  private scrollbar: ScrollbarView;
  private syncEngine: SyncEngine;
  private eventManager: EventManager;
  private config: ConfigManager;

  constructor(target: string | Element, options: Options);
  destroy(): void;
}

// 滚动条视图
class ScrollbarView {
  private element: HTMLElement;
  private thumb: HTMLElement;
  private track: HTMLElement;

  render(): void;
  updateThumb(width: number, left: number): void;
  show(): void;
  hide(): void;
}

// 同步引擎
class SyncEngine {
  private rafId: number;
  private lastScrollLeft: number;

  sync(scrollLeft: number): void;
  startSync(): void;
  stopSync(): void;
}

// 事件管理器
class EventManager {
  private listeners: Map<string, Function[]>;

  on(event: string, callback: Function): void;
  off(event: string, callback: Function): void;
  emit(event: string, data: any): void;
}
```

### 2.2 配置管理系统

```typescript
interface ConfigManager {
  // 默认配置
  readonly defaults: Required<Options>;

  // 配置合并策略
  merge(userOptions: Partial<Options>): Required<Options>;

  // 配置验证
  validate(options: Options): boolean;
}

// 响应式配置
class ReactiveConfig {
  private config: Proxy<Options>;

  update(key: string, value: any): void;
  subscribe(callback: (config: Options) => void): void;
}
```

## 3. 渲染引擎设计

### 3.1 DOM 结构设计

```html
<!-- 生成的浮动滚动条结构 -->
<div
  class="sticky-scrollbar"
  data-scrollbar-id="unique-id"
  style="position: sticky; bottom: 0; left: 0; right: 0; z-index: 9999;"
>
  <div
    class="scrollbar-track"
    style="height: 8px; background: rgba(0,0,0,0.2); border-radius: 4px;"
  >
    <div
      class="scrollbar-thumb"
      style="height: 100%; background: rgba(0,0,0,0.5); border-radius: 4px;"
    ></div>
  </div>
</div>
```

### 3.2 CSS 变量系统

```css
.sticky-scrollbar {
  --scrollbar-height: 8px;
  --scrollbar-bg: rgba(0, 0, 0, 0.2);
  --scrollbar-thumb: rgba(0, 0, 0, 0.5);
  --scrollbar-thumb-hover: rgba(0, 0, 0, 0.7);
  --scrollbar-radius: 4px;
  --scrollbar-opacity: 0.7;
  --scrollbar-hover-opacity: 1;
}
```

## 4. 同步机制设计

### 4.1 滚动同步算法

```typescript
class ScrollSync {
  private container: HTMLElement;
  private scrollbar: HTMLElement;

  // 高精度同步算法
  syncScrollPosition() {
    const containerScrollLeft = this.container.scrollLeft;
    const containerScrollWidth = this.container.scrollWidth;
    const containerClientWidth = this.container.clientWidth;

    const scrollRatio =
      containerScrollLeft / (containerScrollWidth - containerClientWidth);
    const thumbPosition = scrollRatio * (this.scrollbarWidth - this.thumbWidth);

    this.updateThumbPosition(thumbPosition);
  }

  // 防抖优化
  private debounceSync = debounce(this.syncScrollPosition, 16);
}
```

### 4.2 双向绑定机制

```typescript
class BidirectionalSync {
  // 容器到滚动条
  bindContainerScroll() {
    this.container.addEventListener("scroll", this.handleContainerScroll, {
      passive: true,
    });
  }

  // 滚动条到容器
  bindScrollbarDrag() {
    this.scrollbar.addEventListener("mousedown", this.handleDragStart);
    document.addEventListener("mousemove", this.handleDragMove);
    document.addEventListener("mouseup", this.handleDragEnd);
  }
}
```

## 5. 事件系统设计

### 5.1 事件总线

```typescript
class EventBus {
  private events: Map<string, Set<Function>> = new Map();

  emit<T>(event: string, data?: T): void {
    const handlers = this.events.get(event);
    if (handlers) {
      handlers.forEach((handler) => handler(data));
    }
  }

  on<T>(event: string, handler: (data?: T) => void): () => void {
    if (!this.events.has(event)) {
      this.events.set(event, new Set());
    }
    this.events.get(event)!.add(handler);

    // 返回取消订阅函数
    return () => this.events.get(event)?.delete(handler);
  }
}
```

### 5.2 原生事件封装

```typescript
class NativeEventAdapter {
  private resizeObserver: ResizeObserver;
  private mutationObserver: MutationObserver;

  observeContainer() {
    // 监听尺寸变化
    this.resizeObserver = new ResizeObserver((entries) => {
      this.emit("resize", entries[0].contentRect);
    });

    // 监听DOM变化
    this.mutationObserver = new MutationObserver((mutations) => {
      this.emit("domChange", mutations);
    });
  }
}
```

## 6. 性能优化策略

### 6.1 计算缓存

```typescript
class CacheManager {
  private cache = new Map<string, { value: any; timestamp: number }>();

  get<T>(key: string, compute: () => T, ttl = 1000): T {
    const cached = this.cache.get(key);
    if (cached && Date.now() - cached.timestamp < ttl) {
      return cached.value;
    }

    const value = compute();
    this.cache.set(key, { value, timestamp: Date.now() });
    return value;
  }

  clear(): void {
    this.cache.clear();
  }
}
```

### 6.2 虚拟化渲染

```typescript
class VirtualScrollbar {
  private visible = false;
  private intersectionObserver: IntersectionObserver;

  observeVisibility() {
    this.intersectionObserver = new IntersectionObserver((entries) => {
      const entry = entries[0];
      this.visible = entry.isIntersecting;
      this.toggleScrollbar(this.visible);
    });
  }
}
```

## 7. 兼容性设计

### 7.1 浏览器兼容性矩阵

| 功能                 | Chrome 80+ | Firefox 75+ | Safari 13+ | Edge 80+ | IE 11             |
| -------------------- | ---------- | ----------- | ---------- | -------- | ----------------- |
| ResizeObserver       | ✅         | ✅          | ✅         | ✅       | ❌ (polyfill)     |
| IntersectionObserver | ✅         | ✅          | ✅         | ✅       | ❌ (polyfill)     |
| CSS Grid             | ✅         | ✅          | ✅         | ✅       | ❌ (fallback)     |
| Pointer Events       | ✅         | ✅          | ✅         | ✅       | ❌ (mouse events) |

### 7.2 Polyfill 策略

```typescript
class CompatibilityLayer {
  static loadPolyfills() {
    const polyfills = [];

    if (!window.ResizeObserver) {
      polyfills.push(import("resize-observer-polyfill"));
    }

    if (!window.IntersectionObserver) {
      polyfills.push(import("intersection-observer"));
    }

    return Promise.all(polyfills);
  }
}
```

## 8. 错误处理与调试

### 8.1 错误边界

```typescript
class ErrorBoundary {
  static wrap<T extends (...args: any[]) => any>(fn: T, context: string): T {
    return ((...args: Parameters<T>) => {
      try {
        return fn(...args);
      } catch (error) {
        console.error(`[StickyScrollbar:${context}]`, error);
        this.emitError(error, context);
      }
    }) as T;
  }
}
```

### 8.2 开发工具集成

```typescript
class DevTools {
  static enable() {
    if (process.env.NODE_ENV === "development") {
      window.__STICKY_SCROLLBAR__ = {
        instances: new Map(),
        inspect: (id: string) => this.instances.get(id),
        log: (message: string, data?: any) => {
          console.log(`%c[StickyScrollbar] ${message}`, "color: #1890ff", data);
        },
      };
    }
  }
}
```

## 9. 构建与部署

### 9.1 构建配置

```javascript
// rollup.config.js
export default {
  input: "src/index.ts",
  output: [
    {
      file: "dist/sticky-scrollbar.js",
      format: "umd",
      name: "StickyScrollbar",
    },
    { file: "dist/sticky-scrollbar.esm.js", format: "es" },
    { file: "dist/sticky-scrollbar.cjs.js", format: "cjs" },
  ],
  plugins: [
    typescript(),
    babel({ babelHelpers: "bundled" }),
    terser({
      compress: { drop_console: true },
    }),
  ],
};
```

### 9.2 包结构

sticky-scrollbar/
├── dist/
│ ├── sticky-scrollbar.js # UMD 版本
│ ├── sticky-scrollbar.min.js # 压缩版
│ ├── sticky-scrollbar.esm.js # ES 模块
│ └── sticky-scrollbar.d.ts # TypeScript 声明
├── src/
│ ├── index.ts # 入口文件
│ ├── core/ # 核心逻辑
│ ├── utils/ # 工具函数
│ └── types/ # 类型定义
├── examples/ # 使用示例
└── tests/ # 测试文件

## 10. 测试策略

### 10.1 单元测试

```typescript
describe("StickyScrollbar", () => {
  test("should initialize with default options", () => {
    const scrollbar = new StickyScrollbar("#test");
    expect(scrollbar.config.showMode).toBe("auto");
  });

  test("should sync scroll position", () => {
    const container = document.getElementById("container");
    const scrollbar = new StickyScrollbar(container);

    container.scrollLeft = 100;
    expect(scrollbar.getPosition()).toBe(100);
  });
});
```

### 10.2 集成测试

```typescript
describe("Browser Integration", () => {
  test("should work with dynamic content", async () => {
    const container = document.createElement("div");
    const scrollbar = new StickyScrollbar(container);

    // 添加内容
    container.innerHTML = '<div style="width: 2000px; height: 100px;"></div>';
    await waitForUpdate();

    expect(scrollbar.isVisible()).toBe(true);
  });
});
```

## 11. 性能监控

### 11.1 性能指标收集

```typescript
class PerformanceMonitor {
  private metrics = {
    initializationTime: 0,
    syncLatency: [],
    memoryUsage: 0,
  };

  measure(name: string, fn: () => void): number {
    const start = performance.now();
    fn();
    const duration = performance.now() - start;

    this.metrics[name] = duration;
    return duration;
  }
}
```
